/*
most magában lefut
n a csúcsok (pénzek száma)
edge_count véletlenszerű csúcsok közötti, 0.95 és 1.001 közötti átváltással vesz be egy pénzváltót (ez egy elég jóindulatú teszt, mert így sok él esetén van olyan kör, amiben csak 1-nél nagyobb váltások vannak)
az átváltás most lineáris + van egy fix gas_cost amivel nem nagyon foglalkozok

kiír néhány dolgot, hogy milyen kört talált meg, valamint az átváltások után mennyi pénz lett

*/


#include <bits/stdc++.h>

using namespace std;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int maxn=100005;

const double basic_gas_cost=0.01; // gas: jelenleg a starting_nodeopenzbol kell ennyit kell fizetni minden tranzakcioval
const double coin_gas_ratio=1;
const double increased_ratio=1.3; // mennyivel nagyobbat kerdezek hogy legyen viszonyitasi alap, ennel nagyobb novekedesek nem lesznek
const double eps=1e-6;
int n=1000, edge_count=100000, cur_edge_count;
int bal[maxn], jobb[maxn];
int from[maxn], from_id[maxn];
double  gas[maxn], max_amount[maxn], starting_budget=100.0;
vector<pair<int, int> > adj[maxn];


double change_ratio[maxn];


int change_count;
int fontos_szamolas, felesleges_szamolas;

double double_rand(double l, double r) {
    double mul=1e9;
    long long kis=l*mul, nagy=r*mul;
    unsigned long long x=uniform_int_distribution<long long>(kis, nagy)(rng);
    double y=x/mul;
    //cout << "random double " << y << "\n";
    return y;
}
int int_rand(int l, int r) {
    int x=uniform_int_distribution<long long>(l, r)(rng);
    return x;
}
set<pair<double, pair<double, double> > > fixed_changes[maxn];
void add(int a, int b, double rat) {
    cur_edge_count++;
    bal[cur_edge_count]=a, jobb[cur_edge_count]=b;
    change_ratio[cur_edge_count]=rat;
    adj[a].push_back({b, cur_edge_count});

    fixed_changes[cur_edge_count].insert({0, {0, basic_gas_cost}});
}
bool generate_random_edges(int edge_count) {
    for (int i=1; i<=edge_count; i++) {
        int a=int_rand(1, n);
        int b=int_rand(1, n);
        double rat=double_rand(0.95, 1.001);
        //cout << "el " << a << " " << b << "\n";
        if (a==b) continue;
        /*a=i, b=i+1;
        if (b==n+1) b=1;
        rat=1.1;*/
        add(a, b, rat);
    }
}

pair<double, double> calc_change(int id, double val) {
    assert(val>0);
    double sum=val*change_ratio[id];
    double gas=basic_gas_cost;
    //cout << "calc change " << val << " " << sum << "\n";
    return {sum, gas};
}

pair<double, double> try_to_change(int id, double val, bool exact);

pair<double, double> estimate(int id, double val) {
    assert(val>0);
    auto it=fixed_changes[id].upper_bound({val, {0, 0}});
    if (it==fixed_changes[id].end()) {
        try_to_change(id, val*increased_ratio, 1);
        it=fixed_changes[id].upper_bound({val, {0, 0}});
    }
    double big_start=(*it).first, big_change=(*it).second.first, big_gas=(*it).second.second;
    it--;
    double small_start=(*it).first, small_change=(*it).second.first, small_gas=(*it).second.second;

    /*cout << "fontos " << big_start << " " << big_change << " " << small_start << " " << small_change << "\n";
    cout << "proba " << val << "\n";
    cout << "gas: " << small_gas << " " << big_gas << "\n";*/


    double dif=big_start-small_start;
    if (dif<eps) {
        return {small_change, small_gas};
    }
    double from_big=(val-small_start)/dif;
    double from_small=1-from_big;

    double final_sum=small_change*from_small+big_change*from_big;
    double final_gas=small_gas*from_small+big_gas*from_big;

    //cout << "final: " <<final_sum << " " << final_gas << "\n";

    return {final_sum, final_gas};
}


pair<double, double> try_to_change(int id, double val, bool exact) {
    if (!exact) {
        return estimate(id, val); // ha nem 1, akkor csak megbecsuli, hogy mennyi
    }
    change_count++;

    auto p=calc_change(id, val); // ez lesz a feketedoboz az id penzvaltobanal val penzt adok, mennyit kapok vissza
    double sum=p.first, gas=p.second;
    fixed_changes[id].insert({val, {sum, gas}});

    return {sum, gas};
}
bool predict(int cur, int next, int id, double coin_gas_ratio) {
    //return true;
    // meg kell tippelni, hogyha a cur-bol a next-be megyek az id penzvalton, akkor van-e esely, hogy javitani fog
    // cur meg next igazabol nem is kell a fuggvenybe
    //cout << "predict " << cur << " " << next << "\n";
    if (max_amount[cur]<=0) {
        cout << "baj\n";
        exit(0);
    }
    assert(max_amount[cur]>0);
    //return true;

    auto p=estimate(id, max_amount[cur]);
    double next_val=p.first, next_gas=p.second;
    //cout << "uj " << next_val << " " << next_gas << "\n";
    //cout << "regi " << max_amount[next] << " " << gas[next] << "\n";
    if (next_val-next_gas*coin_gas_ratio>max_amount[next]-gas[next]*coin_gas_ratio) {
        return true;
    }
    //cout << "sporolt\n";
    return false;
    /*
    most meg nem akarok vele foglalkozni
    map-be bele kell tenni a try_to_changeasokat
    */
}
bool upd(int cur, int next, int id, double coin_gas_ratio) {
    /*coin_gas_ratio : mennyibe kerul egy egyseg gas
    ha egy kicsit tobbet szerzek, de tobb gas is van, akkor az nem biztos, hogy megeri, mert utana az dragabb lesz try_to_changeani*/
    auto p=try_to_change(id, max_amount[cur], true);
    double next_val=p.first;
    double next_gas=gas[cur]+p.second;

    if (next_val-next_gas*coin_gas_ratio>max_amount[next]-gas[next]*coin_gas_ratio) {
        fontos_szamolas++;
        max_amount[next]=next_val;
        gas[next]=next_gas;
        from[next]=cur;
        from_id[next]=id;
        return true;
    }
    felesleges_szamolas++;
    return false;
}

void calc_spanning_tree(int starting_node, double init_val, double coin_gas_ratio) {
    queue<int> q;
    vector<bool> anc(n+1, 0), inqueue(n+1, 0);

    max_amount[starting_node]=init_val, gas[starting_node]=0;
    from[starting_node]=0;

    q.push(starting_node);
    inqueue[starting_node]=1;

    while (q.size()>0) {
        int cur=q.front();
        q.pop(),
        inqueue[cur]=0;


        int tmp=cur;
        while (tmp) {
            anc[tmp]=1;
            tmp=from[tmp];
        }


        for (auto p:adj[cur]) {
            int next=p.first, id=p.second;
            if (!anc[next] && predict(cur, next, id, coin_gas_ratio)) {
                if (upd(cur, next, id, coin_gas_ratio)) {
                    from[next]=cur;
                    from_id[next]=id;
                    if (!inqueue[next]) {
                        inqueue[next]=1;
                        q.push(next);
                    }
                }

            }
        }

        tmp=cur;
        while (tmp) {
            anc[tmp]=0;
            tmp=from[tmp];
        }

    }

}

pair<vector<int>, vector<int> > find_best_cycle(int starting_node, double coin_gas_ratio) {

    for (int cur=1; cur<=n; cur++) {
        for (auto p:adj[cur]) {
            int next=p.first, id=p.second;
            if (next==starting_node && predict(cur, next, id, coin_gas_ratio)) {
                if (upd(cur, next, id, coin_gas_ratio)) {
                    from[next]=cur;
                    from_id[next]=id;
                }
            }
        }
    }

    vector<int> nodes, ids;
    if (!from[starting_node]) {
        return {{}, {}};
    }
    int a=starting_node;
    do {
        ids.push_back(from_id[a]);
        nodes.push_back(from[a]);
        a=from[a];
    } while (a!=starting_node);

    reverse(nodes.begin(), nodes.end());
    reverse(ids.begin(), ids.end());

    return {nodes, ids};
}
double calc_cycle(vector<int> &nodes, vector<int> &ids, double val) {
    double cur=val, gas=0;
    for (auto id:ids) {
        //cout << "try_to_change " << id << " " << cur << " " << change_ratio[id] << "\n";
        auto p=try_to_change(id, cur, 1);
        cur=p.first, gas+=p.second;
        //cout << "fontos " << p.first << " " << p.second << "\n";
    }
    return cur-gas;
}
pair<double, double> find_optimal_value(vector<int> nodes, vector<int> ids) {
    double search_ratio=100; //
    double lo=starting_budget/search_ratio, hi=starting_budget*search_ratio;
    //cout << "fontos " << starting_budget << " " << lo << " " << hi << "\n";
    int it_count=50;
    double optval=0, optrat=1;
    for (int it=0; it<it_count; it++) {
        double mid1=(2*lo+hi)/3, mid2=(lo+2*hi)/3;
        double sum1=calc_cycle(nodes, ids, mid1), sum2=calc_cycle(nodes, ids, mid2);
        double rat1=sum1/mid1, rat2=sum2/mid2;

        //cout << "proba " << sum1 << " " << mid1 << "\n";

        if (rat1>rat2) { // lehet, hogy a kulonbseget kellene nezni
            hi=mid2;
            if (rat1>optrat) {
                optrat=rat1;
                optval=mid1;
            }
        } else {
            lo=mid1;
            if (rat2>optrat) {
                optrat=rat2;
                optval=mid2;
            }
        }
    }
    return {optval, optrat};
}

int main()
{
    generate_random_edges(edge_count);
    /*add(1, 2, 1.1), add(1, 3, 1.5);
    add(2, 3, 1.1);*/

    calc_spanning_tree(1, starting_budget, coin_gas_ratio); // 1-es csucsbol, valamennyi penzzel szeretnem kiszamolni, hogy mibol mennyit lehet szerezni, ha coin_gas_ratio az atvaltas a gas-ra
    cout << "valtasok szama: " << change_count << "\n";

    cout << "szamolas: " << fontos_szamolas << " " << felesleges_szamolas << "\n";
    /*for (int i=1; i<=n; i++) {
        cout << i << " " << from[i] << "\n";
    }
    cout << "kesz a feszitofa\n";*/
    //exit(0);

    /*for (int i=1; i<=n; i++) {
        cout << i << " " << max_amount[i] << " " << gas[i] << "\n";
    }*/
    auto p=find_best_cycle(1, coin_gas_ratio);

    /*cout << "valtasok szama: " << change_count << "\n";

    cout << "szamolas: " << fontos_szamolas << " " << felesleges_szamolas << "\n";*/

    vector<int> nodes=p.first, ids=p.second;

    /*calc_cycle(nodes, ids, 100);
    return 0;*/

    pair<double, double> p2=find_optimal_value(nodes, ids);
    cout << "kor: ";
    for (auto x:nodes) {
        cout << x << " ";
    }
    cout << "\n";
    cout << "ids: ";
    for (auto x:ids) {
        cout << x << " ";
    }
    cout << "\n";



    double curval=p2.first;
    cout << "starting_amount: " << curval << "\n";
    for (auto id:ids) {
        double next=try_to_change(id, curval, 1).first;
        cout << "valtas " << next << "\n";
        curval=next;
    }

    cout << "kerdesek szama: " << change_count << "\n";

    //cout << "szamolas: " << fontos_szamolas << " " << felesleges_szamolas << "\n";
    return 0;
}
