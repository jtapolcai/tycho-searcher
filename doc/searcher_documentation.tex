\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{enumitem}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{subfig}
\usepackage[svgnames,table]{xcolor}
\usetikzlibrary{arrows.meta}


\title{Arbitrage Cycle Search Heuristic}
\author{Project Tycho}
\date{\today}

\newcommand{\xin}{x_{\text{in}}}
\newcommand{\yout}{y_{\text{out}}}

\usetikzlibrary{shadows, arrows.meta,decorations.markings,positioning,calc,fit}
\tikzset{
  tokenstyle/.style={
    rectangle,
    rounded corners,
    draw=black,
    fill=white,
    drop shadow,
    font=\scriptsize,
  }
}

\begin{document}

\maketitle

\tableofcontents

\section{Overview}
The Tycho Searcher processes real-time blockchain data and identifies arbitrage opportunities. It receives block updates from a data feed, maintains an up-to-date graph of token exchanges, and applies a modified Bellman-Ford algorithm to detect negative cycles, which correspond to profitable arbitrage paths.

\section{System Architecture}
\begin{itemize}[leftmargin=*, label=--]
    \item \textbf{Tycho Feed:} An asynchronous task receives block updates and token data from an external source, and forwards them to the searcher.
    \item \textbf{Searcher:} The searcher maintains the exchange graph, updates it with new data, and runs the arbitrage detection algorithm.
 \end{itemize}
The code is written in rust. It uses asynchronous channels (\texttt{tokio::sync::mpsc}) to communicate between the feed and the searcher.


\section{Searcher Workflow}
\begin{enumerate}[leftmargin=*, label=\arabic*.]
    \item \textbf{Initialization:} The searcher initializes its graph structures and awaits block updates.
    \item \textbf{Block Update Handling:} Upon receiving a new block, the searcher updates the graph with the latest exchange rates and liquidity data.
    \item \textbf{Arbitrage Detection:} The searcher runs the modified Bellman-Ford algorithm to find negative cycles, which indicate arbitrage opportunities.
    \item \textbf{Result Export:} The searcher processes the detected opportunities and can export or log them for further action.
\end{enumerate}

\section{Modified Bellman-Ford Algorithm}
\subsection{Purpose}
The Bellman-Ford algorithm can detect negative cycles in a weighted graph. We have adapted the algorithm to search arbitrage cycles, in order to find cycles with positive profit in the exchange graph. We also consider that the internal state of an Automated Market Maker (AMM) changes after each exchange. We therefore restrict arbitrage cycles to traverse each AMM no more than once.

\subsection{Data Structures}
\begin{itemize}[leftmargin=*, label=--]
    \item \texttt{Graph}: This is a directed graph. Each node represents a token. And each edge corresponds to an AMM and represents the exchange rates between the corresponding tokens.
    \item \texttt{Edge Weights}: 
Each edge $e$ is associated with two functions: $w_e(\xin)$ and $g_e(\xin)$. Here, $w_e(\xin)$ returns the amount of tokens received after the swap, $\yout$. Meanwhile, $g_e(\xin)$ returns the gas used. This is typically a constant function, because the gas cost is usually independent of $\xin$.
\end{itemize}

We assume that $w_e(\xin)$ is a monotone non-decreasing function; that is, increasing the input amount $\xin$ does not decrease the output amount $\yout$. Moreover, the exchange rate $\frac{\yout}{\xin}$ is a monotone non-increasing function of $\xin$.

Each query to $e()$ incurs a computational cost. In practice, a Rust call implements this to \texttt{get\_amount\_out}, which emulates the swap. Both $\xin$ and $\yout$ are stored as large integer values.


\begin{figure}
\centering
\begin{tikzpicture}[>=Stealth, node distance=2cm]
\node[draw] (A) at (0,0) {Token $A$};
\node[draw] (B) at (4,0) {Token $B$};
\node[draw] (C) at (2,1.732) {Token $C$}; % Equilateral triangle
\draw[->] (A) -- node[below] {$e_1$} (B);
\draw[->] (B) -- node[right] {$e_2$} (C);
\draw[->] (C) -- node[left] {$e_3$} (A);
\node[anchor=west, text width=65mm, align=left] at (5,0.8) {If the arbitrage cycle traverses tokens $A \rightarrow B \rightarrow C \rightarrow A$ then it is profitable if and only if 
\begin{multline*}
w_3(w_2(w_1(\xin))) - \xin > \\ p_A\cdot (g_1(\xin) + g_2(\xin) + g_3(\xin))
\end{multline*}
};
\end{tikzpicture}
\caption{An illustration of arbitrage cycle. $p_A$ is the exchange rate for Token $A$ in ether.}\label{fig:arbcycle}
\end{figure}

Fig.~\ref{fig:arbcycle} illustrates an example of an arbitrage cycle. An arbitrage is defined by a closed path in the (exchange) graph and an input amount $\xin$, which is denominated in the start token. The cycle begins and ends at the same token, which we refer to as the \emph{start node} or \emph{start token}.

Arbitrage cycles have two key performance metrics:
\begin{enumerate}
\item Gas cost: the sum of the gas used by each pool along the arbitrage path, including inter-pool transfers;
\item Profit: the net gain in the amount of the start token.
\end{enumerate}

Gas is paid in Ether. So determining whether an arbitrage is profitable requires knowing the start token's price $p$ in ETH. If the start token is WETH, then $p = 1$.

It is important to note that the function $e()$ changes after each swap. Fig. \ref{fig:arbcycle} thus only holds if the three edges belong to different AMMs. For each edge, we therefore explicitly store the pool to which it belongs.

\begin{itemize}[leftmargin=*, label=--]
    \item \texttt{Pools}:  For each edge $e$ we store the associated pool $p(e)$. 
\end{itemize}
    
We restrict the search space to cycles in which every edge belongs to a different pool; that is, for any cycle $C$ and any distinct edges $e,f \in C$, we require $p(e)\neq p(f)$. Although some studies do not impose this restriction on the problem space \cite{diamandis2024convex}, we find that in practice, it has only a minimal impact on solution quality.

\subsection{Precomupations}

As a first step, we decompose the graph into 2-edge-connected components. This enables us to search within each cycle independently.
A 2-edge-connected component is a maximal set of nodes in which every pair of nodes is connected by at least two edge-disjoint paths. For any two nodes in the component, an equivalent cycle passes through each node – even if the cycle is not simple (e.g., it may consist of a figure-eight shape).
This subdivision has several advantages: upon an update, only the affected components need to be recomputed; and the search is also easily parallelizable (although we have not implemented parallelization in our prototype).

In practice, we apply a slightly stronger decomposition, because we know the starting token (node) of the arbitrage cycles (e.g., WETH) in advance.
As a first step, we consider the 2-edge-connected component of the graph that contains the start node. Tokens that are either unreachable from the start node through AMMs, or reachable only via a single AMM, are irrelevant for the purpose of cycle detection.
Next, we temporarily remove the starting node (e.g., WETH) from the graph and compute the connected components of the remaining graph.
When we re-add the starting node, each of these components becomes a subgraph that is only connected to the rest of the graph through the starting node.
This effectively “splits” the search space into independent parts.
It is easy to see that we can search cycles independently in these subgraphs, because any cycle that would traverse multiple components can only cross via the starting node. Any hypothetical cycle that spans multiple components must pass through the starting node. And such a cycle can always be decomposed into smaller cycles contained entirely within individual subgraphs.

\begin{figure}
\centering
\tikzset{
    token/.style={circle, draw, thick, minimum size=7mm, inner sep=0pt, font=\small, fill=white},
    start/.style={draw=black, fill=yellow!30, very thick},
    faint/.style={token, draw=gray!70, fill=gray!10, text=gray!70},
    unreachable/.style={token, draw=gray!60, fill=gray!15},
    amm/.style={<->, thick},
    weak/.style={<->, dashed, gray!70},
    compbox/.style={draw, rounded corners, inner sep=3pt, thick},
    label/.style={font=\footnotesize, align=center}
 }
\subfloat[Original graph with start node WETH]{
\begin{tikzpicture}[]
% Start node
\node[start] (S) at (0,2) {\strut WETH};
% Cluster left (C1-ish around WETH)
\node[token] (a1) at (-1.5,3.2) {A1};
\node[token] (a2) at (-2.3,2.0) {A2};
\node[token] (a3) at (-1.5,0.8) {A3};
\node[token] (a4) at (-0.4,3.1) {A4};
% Edges around S (multiple AMMs)
\draw[amm] (S) -- (a1);
\draw[amm] (S) -- (a3);
\draw[amm] (S) -- (a4);
% Internal edges in left cluster (to hint at 2-edge-connectivity)
\draw[amm] (a1) -- (a2);
\draw[amm] (a2) -- (a3);
\draw[amm] (a3) -- (a1);
\draw[amm] (a1) -- (a4);
% Right cluster (C2)
\node[token] (b1) at (2.0,3.0) {B1};
\node[token] (b2) at (3.0,2.0) {B2};
\node[token] (b3) at (2.0,1.0) {B3};
%
\draw[amm] (S) -- (b2);
\draw[amm] (b1) -- (b2);
\draw[amm] (b2) -- (b3);
\draw[amm] (b3) -- (b1);
% A token reachable only via a single AMM from S (faint)
\node[faint] (x1) at (0.2,0.2) {X};
\draw[weak] (S) -- (x1);
% Unreachable component (grey, no link to S)
\node[unreachable] (u1) at (-3.5,2.8) {U1};
\node[unreachable] (u2) at (-4.2,1.8) {U2};
\node[unreachable] (u3) at (-3.6,0.8) {U3};
\draw[weak] (u1) -- (u2);
\draw[weak] (u2) -- (u3);
\draw[weak] (u3) -- (u1);
\node[label, anchor=north] at (-3.8,0.3) {\scriptsize Unreachable from WETH};
\end{tikzpicture}}
\\
\subfloat[Step1: Remove start node. Identify the connected components of $G \setminus \{\text{WETH}\}$]{\qquad
\begin{tikzpicture}[]
% (No start node here)
% Left component C1
\node[token] (a1b) at (-1.5,3.2) {A1};
\node[token] (a2b) at (-2.3,2.0) {A2};
\node[token] (a3b) at (-1.5,0.8) {A3};
\node[token] (a4b) at (-0.4,3.1) {A4};
\draw[amm] (a1b) -- (a2b);
\draw[amm] (a2b) -- (a3b);
\draw[amm] (a3b) -- (a1b);
\draw[amm] (a1b) -- (a4b);
\node[compbox, fit=(a1b)(a2b)(a3b)(a4b), label] (C1box) {};
\node[label, above=1pt of C1box.north] {\scriptsize $C_1$};
% Right component C2
\node[token] (b1b) at (2.0,3.0) {B1};
\node[token] (b2b) at (3.0,2.0) {B2};
\node[token] (b3b) at (2.0,1.0) {B3};
\draw[amm] (b1b) -- (b2b);
\draw[amm] (b2b) -- (b3b);
\draw[amm] (b3b) -- (b1b);
\node[compbox, fit=(b1b)(b2b)(b3b), label] (C2box) {};
\node[label, above=1pt of C2box.north] {\scriptsize $C_2$};
% Single-edge node becomes singleton (could be filtered out)
\node[faint] (x1b) at (0.2,0.2) {X};
\node[compbox, draw=gray!60, fit=(x1b)] (C3box) {};
\node[label, below=1pt of C3box.south] {\scriptsize $C_3$ (singleton)};
% Unreachable stays its own component
\node[unreachable] (u1b) at (-3.5,2.8) {U1};
\node[unreachable] (u2b) at (-4.2,1.8) {U2};
\node[unreachable] (u3b) at (-3.6,0.8) {U3};
\draw[weak] (u1b) -- (u2b);
\draw[weak] (u2b) -- (u3b);
\draw[weak] (u3b) -- (u1b);
\node[compbox, draw=gray!60, fit=(u1b)(u2b)(u3b)] (C0box) {};
\node[label, above=1pt of C0box.north] {\scriptsize $C_0$ (unreachable)};
\end{tikzpicture}\qquad\qquad}
\\
\subfloat[Add start node back. Independent subgraphs via WETH]{
\begin{tikzpicture}[]
% Start node again
\node[start] (Sc) at (0,2) {\strut WETH};
% C1 + WETH subgraph
\node[token] (a1c) at (-1.5,3.2) {A1};
\node[token] (a2c) at (-2.3,2.0) {A2};
\node[token] (a3c) at (-1.5,0.8) {A3};
\node[token] (a4c) at (-0.4,3.1) {A4};
\draw[amm] (Sc) -- (a1c);
\draw[amm] (Sc) -- (a3c);
\draw[amm] (Sc) -- (a4c);
\draw[amm] (a1c) -- (a2c);
\draw[amm] (a2c) -- (a3c);
\draw[amm] (a3c) -- (a1c);
\node[compbox, fit=(a1c)(a2c)(a3c)(a4c)(Sc)] (S1) {};
\node[label, above=1pt of S1.north,xshift=-1cm] {\scriptsize Subgraph $S_1 = C_1 \cup \{\text{WETH}\}$};
% C2 + WETH subgraph
\node[token] (b1c) at (2.0,3.0) {B1};
\node[token] (b2c) at (3.0,2.0) {B2};
\node[token] (b3c) at (2.0,1.0) {B3};
\draw[amm] (Sc) -- (b2c);
\draw[amm] (b1c) -- (b2c);
\draw[amm] (b2c) -- (b3c);
\draw[amm] (b3c) -- (b1c);
\node[compbox, fit=(b1c)(b2c)(b3c)(Sc)] (S2) {};
\node[label, above=1pt of S2.north,xshift=2cm] {\scriptsize Subgraph $S_2 = C_2 \cup \{\text{WETH}\}$};
% Singleton / filtered (optional)
\node[faint] (x1c) at (0.2,0.2) {X};
\draw[weak] (Sc) -- (x1c);
\node[label] at (0.3,-0.4) {\scriptsize (single-edge, often ignored)};
\end{tikzpicture}}
\caption{Decompose the graph into components for arbitrage cycle search}
\end{figure}

Table \ref{table:graph} reports the graph size, the number of connected components, and the size of the largest component, as a function of the set of pools under consideration. The pools include Uniswap v2, v3, and v4, Ekubo v2, Balancer v2, and Curve. We further filter pools by their total value locked (TVL), measured in Ether.
The table shows that this step yields a significant speedup. For instance, in a graph with $2\,375$ nodes, the largest component contains only $367$ nodes. This illustrates how special the structure of the graph is.

See also Fig. \ref{fig:token_graph}, which shows the graph skeleton of the largest component. This is a simplified representation produced by first removing self-loops and iteratively pruning leaves (degree‑1 nodes), then collapsing degree‑2 chains into single edges marked as skeleton (and marking these edges as dashed lines). These transformations preserve the graph for a cycle search.


\begin{table}
\caption{Performance of the algorithm for pools of various minimum TVL values. }
\label{table:graph}
\centering
\small
\begin{tabular}{cr|rr|r|rr|r}
\hline
\multicolumn{2}{c|}{AMMs} &  \multicolumn{2}{c|}{full graph}& \#compo-& \multicolumn{2}{c|}{largest component} & runtime\\
types&TVL &\#nodes&\#edges&nents&\#nodes&\#edges& \\
\hline
\multirow{3}{*}{\rotatebox{90}{\footnotesize
  \parbox{1.2cm}{\centering Uniswap v2,3,4 Ekubo Balancer curve}}}
&1000 & 111 & 322 & 54 & 47 & 190 & 4.2 s \\
&100 & 623 & 1662 & 435 & 166 & 574 & 12 s \\
&10 & 2467 & 6164 & 1980 & 462 &1924 & 21 s \\
\hline
\multirow{3}{*}{\rotatebox{90}{\footnotesize
  \parbox{1.2cm}{\centering Uniswap v2, v3}}}
&1000 & 78 & 202 & 42 & 26 & 90 & 40 ms \\
&100 & 563 & 1324 & 420 & 126 & 398 & 271 ms \\
&10 & 2375 & 5470 & 1973 & 367 & 1258 & 359 ms \\
\end{tabular}
\end{table}

\begin{figure}
\definecolor{prot_uniswap_v2}{HTML}{FF0000}  % protocol: uniswap_v2
\definecolor{prot_uniswap_v3}{HTML}{0000FF}  % protocol: uniswap_v3
\definecolor{prot_uniswap_v4}{HTML}{00AA00}  % protocol: uniswap_v4
\definecolor{prot_balancer_v2}{HTML}{FF7700}  % protocol: vm:balancer_v2
\definecolor{prot_curve}{HTML}{9900CC}  % protocol: vm:curve
\subfloat[All pools]{
\input{figures/graph_all_amm_tvl10.tex}
} \\
\subfloat[Uniswap v2 and v4 pools]{
\input{figures/graph_uniswap_tvl10.tex}
}
\caption{The sceleton of the token graphs for pools with TVL$\geq10$ Ether, at 22nd of September 2025. Graph skeleton: the core network obtained by removing self-loops and peripheral leaves and collapsing chains of degree‑2 nodes into single (dashed) edges, so the backbone connectivity between hubs is emphasized.}\label{fig:token_graph}
\end{figure}

\subsection{Modified Belmann-Ford}
 
We now explain our most important subrutine. 
In this subrutine, we assume $\xin$ is given, and a subgraph $G=(V,E)$. The task is to find candidate cycles that are profitable; that is,  $w_3(w_2(w_1(\xin))) > \xin$ on Fig. \ref{fig:arbcycle}.  

We define the following data structure:
 \begin{itemize}[leftmargin=*, label=--]
    \item \texttt{Distance\_without\_loop}: 
For each node $v$, we store the maximum attainable output amount $\yout$ (denoted as $d_v$) along a path that does not traverse the same node (token) more than once.
    \item \texttt{Path\_without\_loop}: 
For each node $v$, we store the path $P_v$ toward the start node corresponding to $d_v$.
    \item \texttt{Distance\_with\_a\_single\_loop}: 
For each node $v$, we store a second value, the maximum attainable output amount $\yout$ (denoted as $d^1_v$) along a path that  traverses one node (token) twice, and all other nodes only once.
    \item \texttt{Path\_with\_a\_single\_loop}: 
For each node $v$, we store the corresponding path $P^1_v$ from the start node.
 %   To avoid unnecessary data copying, cycles found by the algorithm are stored as reference-counted vectors. This reduces memory overhead and improves performance.
\end{itemize}



\begin{algorithm}[tb]
\DontPrintSemicolon 
\caption{Modified Belmman-Ford}\label{alg:MBF}
\KwIn{Directed graph $G$, strat node $s$, amount $\xin$, price $p$, max iteration $k_{\max}$}
\nl $d_s=\xin$; $g_s=0$; $d_v=\infty$ and $g_v=0$ for $v\in V \setminus \{s\}$\\
\nl \For{$j \in\{1,\dots, k_{\max}\}$} {
\nl  \For{ $e_{u \rightarrow v} \in E$ }{
\nl     \If{$d_u\neq \infty$ and pool of $e_{u \rightarrow v}$ is not in $P_u$} {
\nl $d',g'=$ \texttt{extend\_path}$(d_u, g_u, P_u, e_{u \rightarrow v})$; \\
\nl       \eIf{$v\neq s$}{
\nl         \eIf{token $v \in P_u$} {
\nl            \If{$d^1_v+p\cdot g^1_v> d'+p\cdot g'$} {
\nl               $d^1_v =d'$;   $g^1_v =g'$;       $P^1_v = P_u + e_{u \rightarrow v}$;\\
\nl		  \texttt{save\_path}$(\xin, P_u + e_{u \rightarrow v})$;
                 }
              }{%else
\nl             \If{$d_v+p\cdot g_v> d'+p\cdot g'$} {
\nl               $d_v =d'$;   $g_v =g'$;       $P_v = P_u + e_{u \rightarrow v}$;        
                }
             }
            }
             {% else loop through s
\nl            \If{$d'>\xin + p \cdot g'$} {
\nl		  \texttt{save\_cycle}$(\xin, P_u + e_{u \rightarrow v})$;
              }        
            }
          }
\nl       \If{$d^1_u\neq \infty$ and pool of $e_{u \rightarrow v}$ is not in $P^1_u$} {
\nl       $d',g'=$ \texttt{extend\_path}$(d^1_u, g^1_u, P^1_u, e_{u \rightarrow v})$; \\
\nl       \eIf{$v\neq s$}{
\nl       \If{token $v \notin P^1_u$} {
\nl       \If{$d^1_v+p\cdot g^1_v> d'+p\cdot g'$} {
\nl            $d^1_v =d'$;   $g^1_v =g'$;       $P^1_v = P^1_u + e_{u \rightarrow v}$;
          }
          }
          }{% else loop through s
\nl            \If{$d'>\xin + p \cdot g'$} {
\nl		  \texttt{save\_cycle}$(\xin, P^1_u + e_{u \rightarrow v})$;
              } 
           }
        }
    }
}
\end{algorithm}


Algorithm \ref{alg:MBF} describes the pseudocode of the algorithm. It has the following steps:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
    \item Initialize distances from the source node to all other nodes as infinity, except the source itself (zero and empty path).
    \item For each edge $u \rightarrow v$, if node $u$ has a finite distance (i.e., $d_u \neq \infty$), attempt to extend the path $P_u$ by adding the edge. See function \texttt{extend\_path} for details.
    Our approach only allows this if the path has not previously used the pool of $e_{u \rightarrow v}$.
    If this results in more tokens than currently recorded at $d_v$,  we need to update our data structures as follows: If the path $P_u$ does not traverse token $v$, we update $d_v$ and $P_v$; otherwise, we update  $d^1_v$ and $P^1_v$. In the latter case, we have found a path from $s$ and with a loop through $v$, which we save as a candidate. Finally, if node $v=s$, we have found a loop.
    \item We perform a similar check if node $u$ has a finite distance with loop (i.e., $d_u \neq \infty$). In this case, we do not deal with the possibility of multiple loops.
    \item Repeat the previous step for $k$ iterations, where $k$ is the maximum path length allowed.
    %\item After the main loop, check for negative cycles by verifying if any edge can still be relaxed. If so, reconstruct the cycle.
    %\item Store detected cycles as \texttt{Rc<Vec<EdgeIndex>>} to minimize cloning and memory usage.
\end{enumerate}

The function \texttt{extend\_path}$(d_u, g_u, P_u, e_{u \rightarrow v})$ returns the token amount and gas usage that result from extending path $P_u$ with edge $e_{u \rightarrow v}$. Note that this can handle cases where the same AMM is traversed multiple times along $P_u + e_{u \rightarrow v}$, by updating its internal state after each traversal.

The function \texttt{save\_cycle}$(\xin, P)$ saves a profitable arbitrage cycle with a given amount $\xin$. Similarly, the function \texttt{save\_path}$(\xin, P)$ saves a profitable path to a token, from which there is an arbitrage cycle. It also stores an amount $\xin$ from the start node. See Fig. \ref{fig:arb_path}.
   
\begin{figure}   
\centering
\begin{tikzpicture}[>=Latex,
  dot/.style={circle,draw,fill=white,inner sep=1.2pt},
  looparrow/.style={thick,postaction={decorate},
    decoration={markings,
      mark=at position 0.25 with {\arrow{Latex}},
      mark=at position 0.75 with {\arrow{Latex}}}}]
\node[dot,label=below:{$\xin$}] (s) at (0,0) {$s$};
\node  (v) at (4,0) {};
\draw[thick,-{Latex}] (s) -- (v);
\draw[looparrow] (5,0) circle [radius=1cm];
\node[dot, label=right:{$d_v < d^1_v$}]  at (v) {$v$};
\end{tikzpicture}
\caption{Illustration of an arbitrage path saved in  \texttt{save\_path}.}\label{fig:arb_path}
\end{figure}



\subsection{Arbitrage search}

Next, we discuss how to find the optimal input amount $\xin$. We begin by running Algorithm~\ref{alg:MBF} with $p = 0$ and a small initial input, for example, $\xin = 0.001$. This typically yields multiple arbitrage cycles. For each identified cycle, we apply a black-box optimization method – the Golden Section Search (GSS) – to find the optimal $\xin$.

GSS is a derivative-free optimization technique for finding the maximum (or minimum) of a unimodal function over a bounded interval. It is particularly suitable when the function’s analytic form is unknown or too expensive to compute, but function evaluations are available. GSS progressively narrows the interval of interest using the golden ratio, requiring only function values at strategically chosen points. In our setting, we use GSS to identify the input amount $\xin$ that maximizes arbitrage profit along a given cycle.

 
\subsection{Optimizations}

To reduce computation time, we divide the graph into subgraphs and solve the problem independently for each subgraph. To compute the subgraphs, we remove the start node $s$ and identify the resulting connected components. We then form each subgraph by reintroducing the start node $s$ and connecting it to a component. We execute the algorithm independently within each subgraph.

To further reduce runtime, we implemented the following memory management strategy.
\begin{itemize}[leftmargin=*, label=--]
    \item \textbf{Reference Counting:} By using \texttt{Rc<Vec<EdgeIndex>>}, the algorithm avoids deep cloning of cycle paths. This is especially beneficial when we detect many cycles.
    \item \textbf{Efficient Graph Updates:} We only update relevant subgraphs per block. This reduces recomputation.
    \item \textbf{BigUint Arithmetic:} We ensure that all calculations are safe from overflow. This is critical for financial computations.
\end{itemize}

\subsection{Summary:}
We have presented a Bellman-Ford algorithm with the following modifications:
\begin{itemize}
    \item We only consider cycles if they start and end at the designated start token (e.g., WETH).
    \item We use reference-counted vectors (\texttt{Rc<Vec<EdgeIndex>>}) to avoid unnecessary cloning.
    \item The algorithm skips cycles that revisit nodes, to avoid infinite loops.
    \item Profit calculation includes gas costs, and only exports cycles with net positive profit.
    \item The Golden Section Search adapts the input range if invalid points are encountered.
\end{itemize}


\bibliographystyle{splncs04}
\bibliography{references}

\end{document} 